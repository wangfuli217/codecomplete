### 24.1.2 核对表：重构总结
cc24(重构总结){}

__数据级的重构__
1. 用具名常量来代替神秘数值
1. 用更明确或更具信息量的名字来重命名变量
1. 将表达式内联化
1. 用函数来代替表达式
1. 引入中间变量
1. 将多用途变量转换为多个单一用途变量
1. 使用局部变量实现局部用途而不是使用参数
1. 将基础数据类型转化为类
1. 将一组类型码转化为类或是枚举类型
1. 将一组类型码转化为含派生类的类
1. 将数组转化为对象
1. 封装集群
1. 用数据类代替传统记录

__语句级的重构__
1. 分解布尔表达式
1. 将复杂的布尔表达式转换为命名精确的布尔函数
1. 将条件语句中不同部分中的重复代码合并
1. 使用break或return而不是循环控制变量
1. 在嵌套的if-then-else语句中一旦知道结果就立刻退出，而不是仅仅赋一个返回值
1. 用多态来代替条件语句(尤其是重复的case语句)
1. 创建并使用空对象代替对空值的检测

__子程序级的重构__
1. 提取子程序
1. 将子程序代码内联化
1. 将冗长的子程序转化为类
1. 用简单的算法代替复杂算法
1. 增加参数
1. 减少参数
1. 将查询操作同修改操作区分开来
1. 合并功能相似的子程序，并用参数来区分它们
1. 通过传递不同的参数使子程序体现不同的功能
1. 传递整个对象而非特定成员
1. 传递特定成员而非整个对象
1. 封装向下转型操作

__类实现的重构__
1. 将值对象改为引用对象
1. 将引用对象改为值对象
1. 用数据初始化来代替虚函数
1. 改变成员函数或数据的位置
1. 将特定代码提出生成派生类
1. 将相似的代码合并起来放到基类中

__类接口的重构__
1. 将某成员子程序放到另一个类中
1. 将一个类转化成两个
1. 删除某个类
1. 隐藏委托关系
1. 去掉中间人
1. 用委托代替继承
1. 用继承代替委托
1. 引入外部子程序
1. 引入扩展类
1. 封装暴露在外的成员变量
1. 对不能修改的成员去掉Set()函数
1. 隐藏在类的外部不会使用的成员函数
1. 封装不会用到的成员函数
1. 如果基类和派生类的代码实现相似，将二者合并

__系统级的重构__
1. 为无法控制的数据创建明确的索引源
1. 将单向类联系改为双向类联系
1. 将双向类联系改为单向类联系
1. 使用工厂函数而非简单的构造函数
1. 用异常代替错误代码，或者反其道而行之