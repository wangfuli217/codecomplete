1. 设计中的挑战
    -> 一个好的类或子程序的设计在很大程度上是由系统的结构所决定的。
    -> 好的高层决策能提供一个可以稳妥容纳多个低层次设计的结构。
    -> 希望软件设计师用一种理性的、不会犯错的从需求说明中推导出设计，这一画面根本就不现实。没有那个系统是用这种方式设计出来的，
以后也不可能有。即便是教科书或者论文中的小型程序开发也是不真实。它都是经过修订和修饰的，直到作者让我们看到他想要做的结果。
因而是不可能在实际中发生的过程。

    -> 险恶问题：-> 必须首先把这个问题解决一遍，以便能够明确地定义它，然后再次解决问题，从而形成一个可行的结果
    
    设计是一个了无章法的过程
        了无章法的过程 -> 在此过程中你会采取很多错误的步骤，多次误入歧途
        了无章法的过程 -> 优劣设计之间的差异往往很微妙
        了无章法的过程 -> 设计过程中会犯错误，且难以判断何时算是足够好
        了无章法的过程 -> 说设计了无章法，还因为你很难判断设计何时算是足够好了

    设计就是确定取舍和调整顺序的过程
        -> 如果快速的反应速度比缩减开发世间更重要，那么设计者会选取一套设计方案。
        -> 如果缩减开发时间更重要，那么好的设计者又要巧妙形成另一套不同的设计方案。
    设计收到诸多限制：
        -> 一部分创造可能发生的事情，
        -> 一部分限制可能发生的事情
    设计是不确定的：-> 如果你让三个人去设计一套同样的程序，他们很可能会做出三套截然不同的设计，而每套设计都很不错。
    设计是一个启发的过程：-> 设计具有一定的探索性 “经验法则”或者“试试没准能行的办法”
    设计是自然而然形成的: -> 设计是在不断的设计评估、非正式讨论、写实验代码以及修改试验代码中演化和完善的。

2. 关键的设计概念
  2.1 管理复杂度
    偶然的难题和本质的难题
    本质: 本质的属性是一件事物必须具备的，如果不具备就不再是该事物的属性
        必须去面对复杂，无序的现实世界
        精确而完整地识别出各种依赖关系与例外情况
        设计出完全正确而不是大致正确的解决方案
    偶然：偶然属性则是一件事物碰巧具有的属性有没有这些属性都并不影响这件事物本身
    
    管理复杂度的重要性
    -> 项目的失败大多数都是由不尽如人意的需求、规划、和管理所导致的。
    +> 当项目确由技术因素导致失败时，其原因通常是失控的复杂度。
    
    应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分，这么做的目的是尽量减少在任一时间所要考虑的程序量。
通过把整个系统分解为多个子系统来降低问题的复杂度。人们更易于理解许多项简单的问题，而不是一项复杂的信息。
    -> 从问题的领域着手，而不是从底层实现细节入手去编写程序，在最抽象的层次上工作，也能减少人的脑力负担

    如何应对复杂度
    高代价、低效率的设计源于以下三种根源：
        用复杂的方法解决简单的问题
        用简单但是错误的方法解决复杂的问题
        用不恰当的复杂方法解决复杂的问题

    要用以下两种方法来管理复杂度：
        把任何人同一时间要处理的本质复杂度的量减少到最小
        不要让偶然性的复杂度无谓地快速增长
    -> 一旦你能够理解软件开发中任何其他技术目标都不如管理复杂度重要的时候，众多设计上的考虑就变得直截了当了。

    理想的设计特征
        最小的复杂度，尽量做出简单且易于理解的设计。
        易于维护，在设计时为做维护工作的程序员着想。
        松散耦合，设计时让程序的各个组成部分关联最小。
        可扩展性，增强系统的功能而无需破坏其底层结构。
        可重用性，可重用性意味着所设计的系统的组成部分能在其他系统中重复使用。
        高扇入，让大量的类使用某个给定的类，设计出的系统很好的利用了在较低层次上的工具类。
        低扇出，让一个类里少量或适中的使用其它的类，一个类使用了大量其他的类因此可能变得过于复杂。
        可移植性，可移植性是说应该这样设计系统，使它能很方便的移植到其他系统。
        精简性，意味着设计出的系统没有多余的部分。
        层次性，意味着尽量保持系统各个分解层的层次性，是你能在任意的层面上观察系统，并得到某种具有一致性的看法。
        标准技术，尽量用标准化的，常用的方法，让整个系统给人一种熟悉的感觉。

    2.2 设计的层次
    软件系统 Software System ->架构定义
    
    分解为子系统或包 Division into Subsystems or Packages -> 模块定义
      -> 最简单的交互关系是让一个子系统去调用另一个子系统中的子程序；
      -> 略微复杂的交互关系是在一个子系统中包含另一个子系统中的类。
      -> 最复杂的交互关系是让一个子系统中的类继承来自另一个子系统中的类。

    分解为包中的类   Division into Classes -> 公有和包括接口定义
        当定义子系统中的类的时候，也就同时定义了这些类与系统的其余部分大交道的细节。尤其是要确定好类的接口。
    
    分解为类中的数据和子程序 Division into Routines -> 私有接口和数据定义
    子程序内部 Internal Routine Design -> 程序(函数)内部实现
        编写伪代码、选择算法、组织子程序内部的代码块，以及用编程语言编写代码.
        
3. 启发式方法
    软件设计是非确定性的，因此，灵活熟练地运用一组有效的启发式方法(试探法)，便成了合理的软件设计的核心工作。
    3.1 找出现实世界中的对象
    步骤：
        辨识对象及其属性（方法和数据）
        确定可以对各个对象进行的操作
        确定各个对象能对其他对象进行的操作
        确定对象的哪些部分对其他对象可见——哪些部分是公用的，哪些部分是使用的
        定义每个对象的公开接口(public interface)
    这些捕捉并无须以特定顺序完成，它们也经常被反复执行，迭代是非常重要的。
    
    3.2 形成一致的抽象
    抽象是一种能让你在关注某一概念的同时可以放心地忽略其中一些细节的能力 --- 在不同的层次处理不同的细节。
    基类是一种抽象，它使你集中精力关注一组派生类所具有的共同特性，并在基类的层次上忽略各个具体派生类的细节。
    一个好的接口也是一种抽象，它能让你关于接口本身而不是类的内部工作方式。

    3.3 封装实现细节
    封装填补了抽象留下的空白，抽象是说：“可以让你从高层次的细节来看待一个对象”。
    封装帮助你管理复杂度的方法是不让你看到那些复杂度。
    封装是说，不只是让你能用简化的视图来看复杂的概念，同时还不能让你看到复杂概念的任何细节，你能看到的就是你能全部得到的

    3.4 当继承能够简化设计时就继承
    继承时面向对象编程中最强大的工具之一，如果使用得当，它能带来极大的益处，然而如果使用不当，它也有极大的弊端。
    
    3.5 信息隐藏
    信息隐藏时结构化程序设计与面向对象设计的基础之一。
    信息隐藏是软件的首要技术使命中格外重要的一种启发式方法，因为它强调的就是隐藏复杂度，这一点无论是从他的名称还是实施细节上都能看的很清楚
        秘密和隐私权
        -> 当信息被隐藏后，每个类（或者包、子程序）都代表了某种对其他类保密的设计或构建决策。
    隐藏起来的秘密可能是某个易变的区域，或者某种文件格式，或者某种数据类型的实现方式，或者某个需要隔离的区域，
    
    -> 信息隐藏总所说的秘密主要分为两大类：
        隐藏复杂度，这样你就不用应付它，除非你需要特别关注的时候
        隐藏变化源，这样当变化发生的时候，其影响就能被限制在局部范围内。复杂度的根源包括复杂的数据类型、文件结构、布尔判断以及晦涩的算法等等。
    
        信息隐藏的障碍
    信息过度分散信息隐藏的常见障碍之一是信息在系统内过度分散
    循环依赖 
    将类中数据误认为全局数据
    可以觉察的性能损耗
    
    这个类需要隐藏什么???
    
    3.6 找出容易改变的区域
        找出看起来容易变化的项目
        将容易变化的项目分离出来
        将看起来容易变化的项目隔离开来
    常见的容易发生变化的区域
        对硬件的依赖性
        输入和输出
        非标准的语言特性
        困难的设计区域和构建区域
        状态变量
        数据量的限制
    
    3.7 预料不同程度的变化
        让这些变化的影响或范围与发生该变化的可能性成反比。
        好方法是：首先找出程序中可能对用户有用的最小子集，这一子集构成了系统的核心，不容易发生改变。接下来，用微小的步伐扩充这个系统。
        
    3.8 保持松散耦合
    像sin()这样的子程序是松散耦合的，因为它需要知道的东西也就是一个传入的、代表角度的数值。
    而诸如InitVar(var1, var2, ..., varN)这样的子程序则耦合得过于紧密了

        规模: 这里的规模指的是模块之间的连接数。
        可见性:可见性指的是两个模块之间的连接的显著程度。
        灵活性:灵活性指的是模块之间的连接是否容易改动。
        
    耦合种类
        简单数据参数耦合simple-data-parameter coupling 两个模块之间通过参数来传递数据，
    并且所有的数据都是简单数据类型时，这两个模块之间的耦合关系就是简单数据参数耦合的，
    这种耦合关系是正常的，可以接受的
        简单对象耦合simple-object coupling 如果一个模块实例化一个对象，那么它们之间的
    耦合关系就是简单对象耦合的。这种耦合也不错
        对象参数耦合object-parameter coupling 如果 Object1 要求 Object2传给它一个Object3，
    那么这两个模块就是对象参数耦合的。与Object1仅要求Object2传递给它简单数据类型相比，
    这种耦合关系要更紧密一些，因为它要求Object2了解Object3。
        语义上的耦合 最难缠的耦合关系是这样发生的：一个模块不仅使用了另一模块的语法元素，
    而且还使用了有关那个模块内部工作细节的语义知识。


    3.9 其他的启发式方法
        高内聚性：类内部的子程序或者子程序内的所有代码在支持一个中心目标上的紧密程度
        构造分层结构：从最通用和最抽象逐渐细化到具有特定意义的概念。
        严格描述类契约：意即描述类与类间的接口
        分配职责：为对象分派好职责
        为测试而设计：为测试而设计很容易产生更为规整的类接口
        避免失误
        有意识的选择绑定时间：指把特定的值绑定到某一变量的时间
        创建中央控制点：对于每一段有作用的代码，应该只有唯一一个地方可以看到它，这样如果需要修改，查找的地方非常少
        考虑使用蛮力突破：可行的蛮力解决方案要好于一个优雅但不能用的方案。
        画一个图：用画图来辅助思考
        保持设计的模块化：与隐藏信息，封装等密切相关
        
4. 设计实践

设计实践的启发式方法：
    迭代
    设计是一种迭代过程，当你在备选的设计方案之中循环并且尝试一些不同的做法时，你将同时从高层和底层的不同视角去审视问题。从高层视角中得出的大范围图景会有助于将相关的底层细节纳入考虑，从底层视角中所获得的细节也会为高层决策奠定基础。

    分而治之
    把程序分解成不同的关注区域，然后分步处理每一个区域，增量式的改进。

    自上而下和自下而上的设计方法
    自上而下死活一种分解策略，从一般性问题出发，分解成可控的部分；自下而上是一种合成策略，从可控的部分出发，构造一个通用的方案。这两种设计方法并不互相排斥，两者的互相协作会让设计受益。

    建立试验性原型
    建立原型是指“写出用于回答特定设计问题的、量最少且能够随时扔掉的代码”，用来判断一种设计方法是否奏效。

    合作设计
    三个臭皮匠顶个诸葛亮。

    确定设计的度
    根据团队的经验、系统的预定寿命、想要得到的可靠度、项目的规模、团队的大小等考虑设计的正规程度。

    记录你的设计成果
    记录设计成果的方法：
        把设计文档插入到代码注释里
        用wiki来记录设计讨论和决策
        写总结邮件
        使用数码相机
        保留设计挂图
        使用CRC（类、职责、合作者）卡片
        在适当的细节层创建UML图
        