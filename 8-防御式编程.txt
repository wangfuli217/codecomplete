防御式编程: 子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。
            承认程序都会有问题，都需要被修改，聪明的程序员应该根据这一点来编程序。
            
1. 保护程序免收非法输入数据的破坏
    检查所有来源于外部的数据的值: 数值: 确保它在可接受的取值范围内。
        指针: 不为NULL。
        字符串: 要确保不超长； 或符合格式需要。
        如企图令缓冲区溢出的数据，注入的SQL指令，注入的HTML或XML代码，整数溢出以及传递给系统调用的数据，等等。
    决定如何处理错误的输入数据。 见 8.3 错误处理技术
    
2. 断言 断言 assertion 是指在开发期间使用的，让程序在运行时进行自检的代码。 -> 把断言看做程序的注释
    -> format: 一个断言通常有两个参数：一个描述假设为真时的布尔表达式，和一个断言为假时需要显示的信息。
    输入参数或输出参数的取值处于预期的范围内；
    -> 子程序开始或者结束执行时文件或流是否处于打开或者关闭的状态；
    -> 子程序开始或者结束执行时，文件或流的读写位置处于开头还是结尾；
    -> 文件或流已用只读，只写或可读写方式打开；
    仅用于输入的变量的值没有被子程序修改；
    指针非空；
    -> 传入子程序的数组或其他容器至少能容纳X个数据元素；
    -> 表已初始化，存储着真实的数据；
    -> 子程序开始或结束执行时，某个容器是空的或满的；
    -> 一个经过高度优化的复杂子程序的运算结果和相对缓慢但代码更清晰的子程序的运算结果一样。

    vs -> 用错误处理代码来处理预期会发生的状况，用断言来处理绝对不应该发生的状况。
          断言是用来检查永远不应该发生的情况，而错误处理代码 error-handling code 是用来检查不太可能经常发生的非正常情况，
    这些情况是能在写代码时就预料到的，且在产品代码中也要处理这些情况。
    -> 错误处理通常用来检查有害的输入数据，而断言是用于检查代码中的bug。
    -> 错误处理代码检查来源不可信的数据，断言检查来源可信的数据。
    -> 断言是防错机制，而错误处理代码是纠错机制。
    
    前条件 precondition 后条件 postcondition  契约式设计 design by contract
    前条件是子程序或类的调用代码在调用子程序或实例化对象之前要确保为true的属性。前条件是调用方代码对其所调用的代码要承担的义务。
    后条件是子程序或类在执行结束后要确保为true的属性。是子程序或类对调用方代码所承担的责任。
    
    massert(e,msg) 退出描述包括退出条件和额外描述信息
    sassert(e)   退出条件即退出描述
    passert(ptr) pointer
    eassert(e)   errno
    zassert(e)   pthread_xxx
3. 错误处理技术: 确定一种通用的处理错误参数的方法，是架构层次(或称高层次)的设计决策。
    在整个程序内采用一致的方式处理非法的参数。 
    在每个系统调用后检查错误码。一旦检查到错误，就记下错误代号和他的描述信息。
    
    返回中立值。继续执行操作并返回一个没有危害的数值。
        数值计算可以返回一个0，
        字符串操作可以返回一个空字符串，
        指针操作可以返回一个空指针，等等。
    换用下一个正确的数据。 流媒体处理
    返回与前次相同的数据。
    换用最接近的合法值。
    -> 把警告信息记录到日志文件中。
    -> 返回一个错误码。如果安全性很重要，要确认调用方的子程序总会检查返回的错误码。
        设置一个状态变量的值。            -> 
        用状态值作为函数的返回值。        -> 
        用语言内建的异常机制抛出一个异常。-> 
    -> 决定系统里的那些部分应该直接处理错误，那些部分只是报告所发生的错误。
    # 调用错误处理子程序或对象。
    # 当错误发生时显示出错信息。
    ->关闭程序。
    # 正确性 correctness：永远不返回不准确的结果。
    # 健壮性 robustness：程序可以持久运行下去，哪怕返回不准确的结果
    
    错误处理常被视为是"代码约定层次 coding-convention-level"的事情。
    1. 错误处理是进行纠正还是仅仅只是检测？
    如果是纠正，程序可以尝试从错误中恢复过来。如果仅仅是检测，那么程序可以就像"没有发生任何事"一样继续运行，也可以退出。
    2. 错误检测是主动检测还是被动检测？ -> 前者可以扫清障碍，后者可以清除混乱。
    系统可以主动地预期错误 -- 例如，通过检查用户输入的有效性
    被动地响应错误 -- 例如，当用户输入的组合产生了一个数值溢出错误时。
    3. 程序如何传播错误？程序一旦检测到错误，它可以立刻丢弃引发错误的数据；也可以把这个错误当成一个错误，并进入错误处理状态
    或者可以等到所有处理完成，再通知用户说在某个地方发现了错误。
    4. 错误消息的处理有约定？如果架构没有详细定义一个一致的处理策略，那用户界面看起来就像"令人困惑的乱七八糟的抽象拼贴图"，
    由程序的不同部分的各种界面拼接而成。要避免这种外观体验，架构应该建立一套有关错误消息的约定
    5. 如何处理异常？何处可以抛出异常？何处可以捕获异常？如何记录异常？如何描述异常？
    架构应该规定代码何时能够抛出异常，在什么地方捕获异常，如何记录这些异常，以及如何在文档中描述异常，等等。
    6. 在程序的什么层次上处理错误？
    7. 每个类在验证其输入数据的有效性方面需要负何种责任？
       是每个类负责校验自己的数据还是有负责整个系统数据有效性校验的一组类？
       某个层次的类是否可以假设数据是干净的？
    8. 是希望使用语言或运行环境内置的错误处理机制还是建立一套自己的体制？
    
4. 异常: 审慎明智地使用时，它可以降低复杂度；而草率粗心地使用时，只会让代码变得几乎无法理解。
         异常是把代码中的错误或异常事件传递给调用代码的一种特殊的手段。
         如果在一个子程序中遇到了预料之外的情况，但不知道该如何处理的话，它就可以抛出一个异常。
         用异常来清理一段代码中存在的杂乱逻辑
         
    子程序使用throw抛出一个异常对象，再被调用链上层其他子程序的try-catch语句捕获。
    https://github.com/hraban/c-exceptions
    https://github.com/paioniu/mezza
    https://github.com/psnc-apps/slurm-drmaa
    https://github.com/pi3orama/currf2
    https://github.com/tglman/orientdb-c
    用异常通知程序的其他部分，发生了不可忽略的错误。
    -> 只有真正例外的情况下才抛出异常。
        异常和断言相似，都用来处理那些不仅罕见甚至永远不该发生的情况。
        一方面他是一种强大的用来处理预料之外的情况的途径，另一方面程序的复杂度会因此增加。
    -> 不能用异常来推卸责任。如果某种错误可以在局部处理，就应该在局部处理掉。
    # 避免在构造函数和析构函数中抛出异常，除非你在同一地方将其捕获。
    -> 在恰当的抽象层次抛出异常。
        抛出的异常也是程序接口的一部分，和其他具体的数据类型一样。
    -> 在异常消息中加入关于导致异常发生的全部信息。
    -> 避免使用空的catch语句。
        如果遇到某个较低层次上的异常确实无法表现为调用方抽象层次上的异常，那么必须写清楚为什么采用空的catch语句。
    了解所用函数库可能抛出的异常。
    
    
    在项目中把对异常的处理标准化：
        为类似C++这种允许抛出多种对象，数据及指针的语言规定可以抛出哪些种类的异常。
        考虑创建项目的特定异常类，可以作为项目中所有可能抛出的异常的基类。
        规定在何种场合允许代码使用throw-catch语句在局部处理错误。
        规定在何种场合允许代码抛出不在局部处理的异常。
        确定是否要使用集中的异常报告机制。
        规定是否允许在构造函数和析构函数中使用异常。
    考虑异常的替代方案。
        有些程序员用异常来处理错误，只是因为他所用的语言提供了这种特殊的错误处理机制。
    你心里应该自始至终考虑各种各样的错误处理机制: 在局部处理错误、使用错误码来传递错误
    在日志文件中记录调试信息、关闭系统或其他的一些方式。
    
5. 隔离程序从而包容由错误造成的损害
    一旦类的公用方法接受了数据，那么类的私有方法就可以假定数据是安全的。
    -> 隔离的使用使断言和错误处理有了清晰地区分。
    隔栏外部的程序应假定所有的数据都是不安全的，并使用错误处理技术对数据进行处理。
    隔栏内部的程序认为数据已经被处理过，是安全的，此时用断言技术。
    一旦隔栏内部的数据发现了错误，那么这个错误应该是程序的错误而不是数据的错误。
    
6. 辅助调试的代码 : 在开发阶段让他显现出来，而在产品代码运行时让他能够自我恢复。
    采用进攻式编程：
        确保断言语句使程序终止运行。
        完全填充已分配到的所有内存。
        完全填充已分配到的所有文件或流。
        确保每一个case语句中的default分支或else分支都能产生严重的错误，或者至少让这些错误不会被忽视。
        让程序把他的错误日志文件用email发给你。
    使用类似ant和make这样的版本控制工具和make工具。
    使用内置的预处理器。

7. 最终的产品代码中应该保留多少防御式代码
8. 对防御式编程采取防御的姿态