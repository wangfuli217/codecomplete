2. 软件隐喻
隐喻: 与其说一个软件隐喻像是一张路线图，还不如说它是一盏探照灯。 
      它不会告诉你到哪里去寻找答案，而仅是告诉你该如何去寻找答案。
      隐喻的作用更像启示(heuristic，启发、试探法)，而不是算法(algorithm)。
      
算法 ：算法是一套定义明确的指令，使你能完成某个特定的任务。
算法是可预测的(predictable)、确定性的(deterministic)、不易变化的(not subject to chance)。

算法和隐喻差别就在于其距离最终解决方法的间接程度；
    算法直接给你解决问题的指导，
    启发式方法则告诉你该如何发现这些指导信息，或者至少到哪里去寻找它们。

1. 隐喻的价值: 
    隐喻的价值绝不应低估。隐喻的优点在于其可预期的效果：能够被所有的人理解。不必
要的沟通和误解也因此大为减低，学习与教授更为快速。实际上，隐喻是对概念进行内在化
(internalizing)和抽象(abstracting)的一种途径，它让人们在更高的层面思考问题，从而
避免低层次的错误。
    科学发展的历史并不是一系列从“错误”的隐喻到“正确”的隐喻的转变，而是一系列从
“不太合适”的隐喻到“更好”的隐喻的转变，也是从不是很贴切的隐喻到更贴切的隐喻的转变。

3. 常见的软件隐喻
编写软件是一门科学，是一门艺术，是一个过程。
        像驾驶汽车，像一场游戏，像园艺，是一个集市，
  -> David Gries 说编写软件是一门科学 (a science)(1981)
  -> Donald Knuth 说它是艺术 (an art)(1998)
  -> Watts Humphrey 则说它是一个过程 (a process)(1989)
  -> P.J.Plauger 和 Kent Beck 都说它就像是驾驶汽车(Driving a car)
  -> Alistair Cockburn 说它是一场游戏(a game)(2002)
  -> Eric Raymond 又说它就如同是一个集市(bazzar)(2000)
  -> Andy Hunt 和 Dave Thomas 说它就像园艺(gardening)一样
  -> Paul Hecker 则说它就像是拍摄《白雪公主和七个小矮人》(1994)
  -> Fred Brooks 说它像耕田、像捕猎、或像是跟恐龙一起淹死在“焦油坑”里面(1995)
    写作 writing 
        《文体的要素》 -> 《编程风格的要素》 《The Elements of Programming Style》-> 程序的可读性（readability）
        文字写作这一隐喻暗示着软件开发过程是一中代价昂贵的试错过程，而非仔细的规划和设计。
    培植系统 growing
        你一次设计系统的一小部分、写出一段代码、做一点测试，并将成果一点点添加到整个系统中。
    通过这种小步前进，你可以把每次可能遇到的麻烦减到最小。
        软件耕种这一隐喻的弱点在于它暗示了人们将无法对开发软件的过程和方式进行任何直接的控制。
    牡蛎养殖观点：系统生长 system  accretion -> 增量式开发的优势在于未做过度的承诺。 
        生长密切相关的另一些词语有
          增量的(incremental)
          迭代的(iterative)
          自适应的(adaptive)
          演进的(evolutionary)
        以增量方式进行设计、编译和测试，都是目前已知最强有力的软件开发概念。
    建造软件 building
        建造软件暗示了软件开发中存在着诸多阶段，如计划、准备及执行等，根据所建造软件的不同，这些阶段的种类和程度可能会发生变化。
        
        问题定义(problem definition)：首先你要决定准备建一个什么类型的房子
        软件架构设计(architectural design)：必须和某个建筑师探讨这一总体设计，并得到批准
        软件的构建(construction)：准备好建造地点、打好地基、搭建房屋框架、砌好边墙、盖好房顶、通好水电煤气等
        软件的优化(oprimization)：这种房子大部分完成之后，要对新盖的家美化一番
        软件复查(review)、审查(inspection)：监查人员来检查工地、地基。布线以及其他需要检查的地方
        
        