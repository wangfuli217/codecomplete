21 按合约设计
在写函数的时候，入口处assert输入参数，出口处返回该调用是否成功是最基本的。只是我们没有比较正式的将其称为前条件、后条件并注释出来。当然，也会在入口，出口处检查某个状态是否成立，这应该就是这里指的“不变项”。我想，明确这些概念，可以让我们在写代码的时候有比较清晰的思路来保证函数的规范性。实现一个函数的时候先思考一下，它的合约是什么呢~~~

22 死程序不说谎
当程序中有致命错误时，直接crash会是比较好的选择。因为这样是以最明确的方式报告了错误，便于修正。如果试图掩盖这种错误，虽然程序还是运行着，却有着潜在的危险。比如C++中两次迭代的异常会导致程序crash，如果你试图在析构函数中吞下第二个异常，其实是掩盖了错误，而不是解决了问题。
与其苟延残喘的活着，不如给他痛痛快快的来一刀吧!

23 断言式编程
这是防御式编程的重要组成部分，如果你觉得“不可能”发生，那就用断言确保它不会发生。当然，注意这里是“不可能”发生，很多初学者很容易认为在失败的时候就assert，比如流程：为打开一个文件，如果不存在，则先创建它。那么在第一步打开文件失败时，很多人会错误的使用一个assert，而其实，这是“可能”的情况。

24 何时使用异常
对于错误处理的方式，异常处理比返回值判断的好处在于：减少了条件判断；把错误处理的代码集中到了一起。但是我们工作中用的最多的，还是返回值处理。
在异常处理中，一个很重要的措施是保证异常抛出时，资源能被正确的释放掉，在C++中，我们可以用RAII，而在C#，或者Java中，我们可以利用finally语句。

25 怎样配平资源
关于资源管理的章节
几个原则吧：
    1. 谁分配谁释放
    2. 先分配的后释放 --- 以防后分配的对先分配的有引用
    3. 在代码不同的地方以相同次序分配资源 --- 避免死锁